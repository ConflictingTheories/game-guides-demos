<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Advanced Game Engine Patterns — JRPG · RTS · SRPG · Action RPG · Platformer MMO · MMO</title>
    <link rel="stylesheet" href="./guide-style.css" />
    <!-- mermaid -->
    <script src="/lib/mermaid.min.js"></script>
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'dark',
            securityLevel: 'loose',
            flowchart: { useMaxWidth: true, htmlLabels: true }
        });
    </script>
</head>

<body>
    <header>
        <h1>Part II — Graphics: Advanced OpenGL & WebGL Fundamentals</h1>
        <p class="section-intro">Deep dive into rendering pipelines, math, and techniques for real-time engines.
            Includes advanced topics like ray marching, compute shaders, and optimization strategies.</p>

        <div class="toc">
            <div class="chip active" data-section="all">Show All</div>
            <div class="chip" data-section="advanced">Advanced</div>
        </div>
    </header>

    <!-- Show All Button (fallback) -->
    <button id="show-all-btn">Show All Sections</button>

    <!-- Graphics Part -->
    <section id="advanced" class="section">
        <div class="row">
            <div class="col">
                <h3>Rendering Pipeline (Conceptual, Expanded)</h3>
                <p class="note">GPU flow: CPU batches -> vertex processing -> raster -> fragment. Optimize with bindless
                    textures, multi-draw indirect, and GPU culling to handle 1M+ draws.</p>
                <div class="diagram">
                    <div class="mermaid">
                        graph TD
                        A[CPU Batch Prep] --> B[Upload Buffers (VBO/IBO/UBO)]
                        B --> C[Vertex Shader]
                        C --> GS[Geometry Shader (Optional)]
                        GS --> TS[Tessellation (Optional)]
                        TS --> D[Primitive Assembly]
                        D --> E[Fragment Shader]
                        E --> F[Depth/Stencil Tests]
                        F --> G[Blending & Framebuffer]
                        subgraph Compute
                        H[Compute Shaders for Culling/Particles]
                        end
                        H --> A
                    </div>
                </div>

                <h3>Key GL/WebGL Concepts (Expanded)</h3>
                <ul>
                    <li>Buffers: Use persistent mapping for dynamic updates; SSBOs for arbitrary data.</li>
                    <li>Textures: Bindless arrays, sparse textures for megatextures.</li>
                    <li>Framebuffers: Multi-sampled for AA; attachments for G-buffer in deferred.</li>
                    <li>State: Minimize changes with uber-shaders compiling variants.</li>
                </ul>
                <div class="tip">
                    <strong>Professional Tip</strong>: Use AZDO (Approaching Zero Driver Overhead) techniques—group by
                    material, use indirect draws.
                </div>
            </div>

            <div class="col">
                <h3>Shaders & GLSL Patterns (Expanded)</h3>
                <div class="pattern">
                    <strong>PBR vs. Blinn-Phong</strong>
                    <p class="note">PBR for realism: IBL, GGX specular. Blinn for mobile/stylized.</p>
                </div>
                <div class="pattern">
                    <strong>Compute Shaders (New)</strong>
                    <p class="note">For GPU particles, culling, or simulation (e.g., fluid dynamics).</p>
                </div>
                <h3>GLSL Snippet — Advanced Vertex with Skinning</h3>
                <pre>// vertex.glsl
attribute vec3 a_pos;
attribute vec2 a_uv;
attribute vec4 a_boneIds;
attribute vec4 a_weights;
uniform mat4 u_mvp;
uniform mat4 u_bones[64];
varying vec2 v_uv;
void main(){
  mat4 skin = u_bones[int(a_boneIds.x)] * a_weights.x + ...; // Sum weighted
  vec4 pos = skin * vec4(a_pos, 1.0);
  gl_Position = u_mvp * pos;
  v_uv = a_uv;
}</pre>
                <h3>GLSL Snippet — PBR Fragment</h3>
                <pre>// fragment.glsl
precision mediump float;
varying vec2 v_uv;
uniform sampler2D u_albedo, u_normal, u_roughness;
void main(){
  vec3 albedo = texture2D(u_albedo, v_uv).rgb;
  // Compute lighting with GGX, Fresnel, etc.
  gl_FragColor = vec4(computePBR(albedo, ...), 1.0);
}</pre>
            </div>
        </div>

        <hr style="opacity:.06" />

        <div class="row">
            <div class="col">
                <h3>Math Primer — Vectors & Matrices (Expanded)</h3>
                <p class="note">Column-major in GL; use quats for rotations to avoid gimbal lock. Advanced: Dual quats
                    for skinning.</p>
                <ul>
                    <li>Vec3/4: SIMD ops for speed.</li>
                    <li>Mat4: Decompose for interpolation.</li>
                    <li>Quats: Slerp for anim blends.</li>
                </ul>
                <div class="diagram">
                    <div class="mermaid">
                        graph TD
                        A[Model Space] -->|Model Mat| B[World Space]
                        B -->|View Mat| C[View Space]
                        C -->|Proj Mat| D[Clip Space]
                        D -->|Perspective Divide| E[NDC]
                        E -->|Viewport| F[Screen Space]
                        subgraph Advanced
                        G[Inverse Mats for Raycasting]
                        end
                        F --> G --> A
                    </div>
                </div>

                <h3>Important Formulas (Expanded)</h3>
                <pre>// LookAt View
mat4 lookAt(vec3 eye, vec3 center, vec3 up) {
  vec3 f = normalize(center - eye);
  vec3 s = normalize(cross(f, up));
  vec3 u = cross(s, f);
  return mat4(vec4(s, -dot(s, eye)), vec4(u, -dot(u, eye)), vec4(-f, dot(f, eye)), vec4(0,0,0,1));
}

// Ortho Proj
mat4 ortho(float l, float r, float b, float t, float n, float f) {
  return mat4(vec4(2/(r-l),0,0,0), vec4(0,2/(t-b),0,0), vec4(0,0,2/(n-f),0), vec4(-(r+l)/(r-l), -(t+b)/(t-b), (f+n)/(n-f),1));
}</pre>
            </div>

            <div class="col">
                <h3>Camera Systems (Expanded)</h3>
                <p class="note">Third-person with collision avoidance; cinematic with spline paths. Use jitter for TAA.
                </p>
                <div class="diagram">
                    <div class="mermaid">
                        graph TD
                        Controller[Camera Controller] --> Transform[Camera Transform]
                        Transform --> View[View Matrix]
                        View --> Shader[Uniform u_view]
                        Shader --> Proj[Projection Matrix]
                        Proj --> Clip[Clip Space]
                        Note right of Controller: Handle Shakes, Zooms
                    </div>
                </div>

                <h3>Practical Tips (Expanded)</h3>
                <ul>
                    <li>Floating origin for vast worlds.</li>
                    <li>Reverse-Z for depth precision.</li>
                    <li>Frustum + occlusion culling with GPU queries.</li>
                    <li>Advanced: Ray marching for volumetrics.</li>
                </ul>
                <div class="tip">
                    <strong>Professional Tip</strong>: Profile shaders with NVIDIA Nsight—optimize branches.
                </div>
            </div>
        </div>

        <hr style="opacity:.06" />

        <div class="row">
            <div class="col">
                <h3>Advanced Topics — Batching, Instancing, LOD (Expanded)</h3>
                <p class="note">Multi-draw indirect for foliage; mesh shaders for next-gen.</p>
                <div class="diagram">
                    <div class="mermaid">
                        graph TD
                        Entities[Many Entities] --> InstBuffer[Instance Buffer (Mats, Colors)]
                        InstBuffer --> Draw[glDrawElementsInstanced]
                        Draw --> GPU[GPU Processes in Parallel]
                        GPU --> Screen
                        Note right of Draw: Reduce CPU Calls
                    </div>
                </div>
                <h3>Shadow Mapping & Lighting (Expanded)</h3>
                <p class="note">CSM with VSM for soft shadows; clustered lighting for many lights.</p>
            </div>

            <div class="col">
                <h3>Post-Processing & HDR (Expanded)</h3>
                <p class="note">ACESTonemap; bloom with mip chains; TAA for anti-aliasing.</p>
                <div class="diagram">
                    <div class="mermaid">
                        sequenceDiagram
                        Scene->>HDR: Render High Dynamic
                        HDR->>Extract: Bright Pass
                        Extract->>Blur: Gaussian Mips
                        Blur->>Composite: Add to ToneMapped
                        Composite->>TAA: Temporal AA
                        TAA->>Screen: Final sRGB
                    </div>
                </div>
            </div>
        </div>

        <hr style="opacity:.06" />

        <div class="row">
            <div class="col">
                <h3>WebGL Specifics (Expanded)</h3>
                <ul>
                    <li>Extensions: WEBGL2 for transforms feedback.</li>
                    <li>Streaming: Use OffscreenCanvas for workers.</li>
                    <li>Context: Handle loss with resource managers.</li>
                </ul>
                <h3>Example — Minimal WebGL Setup (JS, Expanded)</h3>
                <pre>// With instancing
const program = createProgram(gl, vs, fs);
const vao = gl.createVertexArray();
gl.bindVertexArray(vao);
// Setup attributes...
gl.bindBuffer(gl.ARRAY_BUFFER, instanceBuffer);
gl.vertexAttribDivisor(location, 1); // Per instance
gl.drawElementsInstanced(gl.TRIANGLES, indices, gl.UNSIGNED_SHORT, 0, instanceCount);</pre>
            </div>

            <div class="col">
                <h3>Precision & Profiling (Expanded)</h3>
                <ul>
                    <li>Tools: RenderDoc, WebGPU Inspector.</li>
                    <li>Optimizations: Half-floats for normals; texture compression (Basis).</li>
                    <li>GPU Anim: Vertex texture fetch for skinning.</li>
                </ul>
                <div class="tip">
                    <strong>Professional Tip</strong>: Target 60fps with VSync; use requestAnimationFrame in WebGL.
                </div>
            </div>
        </div>

        <hr style="opacity:.06" />

        <div class="row">
            <div class="col">
                <h3>Cheat Sheet — Matrix Conventions</h3>
                <pre>// Multiply order: P * V * M * vec
// Flatten column-major for uniform buffers</pre>
                <h3>Quaternion Quick Rules (Expanded)</h3>
                <ul>
                    <li>Normalize post-ops; NLerp for cheap, Slerp for constant speed.</li>
                    <li>Dual quats: For linear blend skinning without artifacts.</li>
                </ul>
            </div>

            <div class="col">
                <h3>Common Gotchas (Expanded)</h3>
                <ul>
                    <li>Matrix order mismatches.</li>
                    <li>Depth artifacts: Log-depth buffers alternative to reverse-Z.</li>
                    <li>Gamma: Linear workflow essential for PBR.</li>
                    <li>WebGL: Precision qualifiers for mediums/highp.</li>
                </ul>
            </div>
        </div>

    </section>

    <footer>
        <p>Notes: This enhanced guide draws from professional insights and case studies for advanced development. Adapt
            diagrams and code to your tech stack. If Mermaid fails, check CDN.</p>
        <p>— Happy hacking. Prototype small, iterate fast, scale smart.</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const chips = document.querySelectorAll('.chip');
            const sections = document.querySelectorAll('.section');
            const showAllBtn = document.getElementById('show-all-btn');

            function showSection(id) {
                sections.forEach(sec => {
                    sec.classList.toggle('active', id === 'all' || sec.id === id);
                });
                chips.forEach(chip => {
                    chip.classList.toggle('active', chip.dataset.section === id || id === 'all');
                });
            }

            chips.forEach(chip => {
                chip.addEventListener('click', () => {
                    const section = chip.dataset.section;
                    showSection(section);
                });
            });

            showAllBtn.addEventListener('click', () => {
                showSection('all');
            });
            showSection('advanced');
        });
    </script>
</body>

</html>