<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Matrix Skybox (WebGL2)</title>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: black;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>

<body>
  <canvas id="glcanvas"></canvas>
  <script type="module">
    const vsSource = `#version 300 es
precision highp float;
in vec3 a_position;
uniform mat4 u_view;
uniform mat4 u_proj;
out vec3 v_dir;
void main(){
  vec4 rotPos = u_view * vec4(a_position, 0.0);
  v_dir = rotPos.xyz;
  gl_Position = u_proj * vec4(rotPos.xyz, 1.0);
}`;

    // --- fragment shader ---
    const fsSource = `#version 300 es
precision highp float;
in vec3 v_dir;
out vec4 fragColor;
uniform float u_time;
uniform vec2 u_resolution;

// hash + noise helpers
uint wangHash(uint x){x=(x^61u)^(x>>16);x*=9u;x=x^(x>>4);x*=0x27d4eb2du;x=x^(x>>15);return x;}
float hash12(vec2 p){uint a=uint(floatBitsToUint(p.x));uint b=uint(floatBitsToUint(p.y));
  return float(wangHash(a+374761393u*b))/4294967295.0;}
float noise2(vec2 p){vec2 i=floor(p);vec2 f=fract(p);
  float a=hash12(i),b=hash12(i+vec2(1,0)),c=hash12(i+vec2(0,1)),d=hash12(i+vec2(1,1));
  vec2 u=f*f*(3.-2.*f);
  return mix(a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y;}
float pulse(float x,float w){return smoothstep(0.,w,x)*(1.-smoothstep(1.-w,1.,x));}

void main(){
  vec3 dir=normalize(v_dir);
  float u=atan(dir.z,dir.x)/(2.0*3.1415926)+0.5;
  float v=asin(clamp(dir.y,-1.,1.))/3.1415926+0.5;
  vec2 uv=vec2(u,v);
  float colsBase=mix(120.,240.,clamp(u_resolution.x/1600.,0.,1.));
  float horizonBias=1.-abs(v-0.5)*2.;
  float cols=max(32.,colsBase*(0.6+0.8*horizonBias));
  float colIndexF=floor(uv.x*cols);
  float colX=(colIndexF+0.5)/cols;
  float seed=hash12(vec2(colIndexF,floor(u_time*10.)));
  float speed=0.8+hash12(vec2(colIndexF,9.))*2.2;
  float charSize=mix(0.018,0.035,clamp(u_resolution.y/900.,0.,1.));
  float rows=1./charSize;
  float yScaled=uv.y*rows;
  float yCell=floor(yScaled);
  float yFrac=fract(yScaled);
  float dropPos=fract(seed*7.3+u_time*0.25*speed);
  float drop2=fract(seed*3.1+u_time*0.57*speed*0.7);
  float d1=abs(yCell/rows-dropPos);
  float d2=abs(yCell/rows-drop2);
  float head=exp(-pow((yFrac+fract(yCell*0.9183)*0.35),2.)*40.);
  float tail=exp(-d1*8.)+0.5*exp(-d2*12.);
  float glyphSeed=hash12(vec2(colIndexF,yCell));
  float glyphPulse=pulse(fract(yScaled-(seed*3.+u_time*0.9*speed)),0.12);
  float glyph=smoothstep(0.35,0.55,glyphSeed+0.2*noise2(vec2(colIndexF*0.13,yCell*0.07+u_time*0.1)));
  float brightness=clamp(1.6*head+0.9*tail*glyph+0.35*glyph*glyphPulse,0.,1.6);
  float colWidth=1./cols*0.9;
  float colMask=smoothstep(0.,1.,1.-abs(uv.x-colX)/(colWidth*0.6));
  float jitter=noise2(vec2(colIndexF*0.7,yCell*0.9+u_time*0.2))*0.5;
  float charV=smoothstep(0.,1.,1.-abs(yFrac-(0.5+jitter*0.2))*2.);
  float intensity=brightness*colMask*charV;
  vec3 baseGreen=vec3(0.1,0.95,0.15);
  vec3 headColor=mix(baseGreen*0.6,vec3(1.0,1.0,0.9),clamp(head*2.,0.,1.));
  vec3 tailColor=baseGreen*(0.6+0.8*glyph);
  float headFactor=clamp(head*2.,0.,1.);
  vec3 col=mix(tailColor,headColor,headFactor)*intensity;
  float bgNoise=0.04*(noise2(uv*400.+u_time*0.03));
  float verticalVignette=pow(1.-abs(v-0.5)*1.6,1.8);
  vec3 bg=vec3(0.01,0.03,0.01)*verticalVignette+bgNoise;
  float stars=smoothstep(0.9996,1.,noise2(uv*2000.+u_time*0.1));
  vec3 starCol=vec3(0.6,1.0,0.6)*stars*1.2;
  vec3 final=col+bg+starCol;
  float glow=pow(intensity,1.6)*0.9;
  final+=vec3(glow*0.14,glow*0.22,glow*0.06);
  final=1.-exp(-final*1.6);
  final=pow(final,vec3(0.9));
  fragColor=vec4(final,1.0);
}`;

    // ---- JS setup ----
    const canvas = document.getElementById('glcanvas');
    const gl = canvas.getContext('webgl2');
    if (!gl) { alert('WebGL2 not supported'); }

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener('resize', resize); resize();

    function compileShader(src, type) {
      const sh = gl.createShader(type);
      gl.shaderSource(sh, src);
      gl.compileShader(sh);
      if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(sh));
      }
      return sh;
    }
    function createProgram(vsSrc, fsSrc) {
      const vs = compileShader(vsSrc, gl.VERTEX_SHADER);
      const fs = compileShader(fsSrc, gl.FRAGMENT_SHADER);
      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(prog));
      }
      return prog;
    }
    const program = createProgram(vsSource, fsSource);
    gl.useProgram(program);

    const cubeVerts = new Float32Array([
      -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, // back
      -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1  // front
    ]);
    const cubeIdx = new Uint16Array([
      0, 1, 2, 2, 3, 0,
      4, 5, 6, 6, 7, 4,
      0, 4, 7, 7, 3, 0,
      1, 5, 6, 6, 2, 1,
      3, 2, 6, 6, 7, 3,
      0, 1, 5, 5, 4, 0
    ]);
    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    const vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, cubeVerts, gl.STATIC_DRAW);
    const aPos = gl.getAttribLocation(program, "a_position");
    gl.enableVertexAttribArray(aPos);
    gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);
    const ibo = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIdx, gl.STATIC_DRAW);

    // uniforms
    const uView = gl.getUniformLocation(program, "u_view");
    const uProj = gl.getUniformLocation(program, "u_proj");
    const uTime = gl.getUniformLocation(program, "u_time");
    const uRes = gl.getUniformLocation(program, "u_resolution");

    function perspective(fovy, aspect, near, far) {
      const f = 1.0 / Math.tan(fovy / 2), nf = 1 / (near - far);
      return new Float32Array([
        f / aspect, 0, 0, 0,
        0, f, 0, 0,
        0, 0, (far + near) * nf, -1,
        0, 0, (2 * far * near) * nf, 0
      ]);
    }
    function lookAt(eye, center, up) {
      const z = normalize(sub(eye, center));
      const x = normalize(cross(up, z));
      const y = cross(z, x);
      return new Float32Array([
        x[0], y[0], z[0], 0,
        x[1], y[1], z[1], 0,
        x[2], y[2], z[2], 0,
        0, 0, 0, 1
      ]);
    }
    function sub(a, b) { return [a[0] - b[0], a[1] - b[1], a[2] - b[2]]; }
    function cross(a, b) { return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]]; }
    function normalize(v) { const l = Math.hypot(v[0], v[1], v[2]); return [v[0] / l, v[1] / l, v[2] / l]; }

    let start = performance.now();
    function render() {
      const t = (performance.now() - start) / 1000;
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.useProgram(program);
      gl.bindVertexArray(vao);
      const aspect = canvas.width / canvas.height;
      const proj = perspective(60 * Math.PI / 180, aspect, 0.1, 100.0);
      const eye = [0, 0, 0];
      // rotate slowly around Y
      const angle = t * 0.1;
      const view = lookAt(
        [Math.sin(angle) * 0.0, 0, Math.cos(angle) * 0.0],
        [0, 0, -1],
        [0, 1, 0]
      );
      gl.uniformMatrix4fv(uView, false, view);
      gl.uniformMatrix4fv(uProj, false, proj);
      gl.uniform1f(uTime, t);
      gl.uniform2f(uRes, canvas.width, canvas.height);
      gl.drawElements(gl.TRIANGLES, cubeIdx.length, gl.UNSIGNED_SHORT, 0);
      requestAnimationFrame(render);
    }
    render();
  </script>
</body>

</html>