<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>AOI MMO Ghost Trail + Rollback Fade</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #222;
            color: #eee;
            font-family: sans-serif;
        }

        .canvas-container {
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
            position: relative;
        }

        canvas {
            border: 1px solid #555;
            background: #111;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
        }

        label {
            margin-right: 5px;
        }

        .timeline {
            font-size: 12px;
            color: #fff;
            margin-top: 5px;
        }
    </style>
</head>

<body>

    <div class="canvas-container">
        <canvas id="client1" width="400" height="400"></canvas>
        <canvas id="client2" width="400" height="400"></canvas>
    </div>

    <div class="controls">
        <div>
            <label>Client1 Latency: <span id="latVal1">100</span>ms</label>
            <input type="range" id="latSlider1" min="0" max="500" value="100">
        </div>
        <div>
            <label>Client2 Latency: <span id="latVal2">100</span>ms</label>
            <input type="range" id="latSlider2" min="0" max="500" value="100">
        </div>
    </div>

    <div class="timeline" id="timeline1">Client1 Timeline:</div>
    <div class="timeline" id="timeline2">Client2 Timeline:</div>

    <script>
        // ===== CONFIG =====
        const CELL_SIZE = 100;
        const WORLD_WIDTH = 400;
        const WORLD_HEIGHT = 400;
        const ENTITY_COUNT = 8;
        const AOI_CELLS = 1;
        const SERVER_TICK = 60;
        const TRAIL_LENGTH = 20;

        // ===== WORLD ENTITIES =====
        let entities = [];
        for (let i = 0; i < ENTITY_COUNT; i++) {
            entities.push({
                id: i,
                x: Math.random() * WORLD_WIDTH,
                y: Math.random() * WORLD_HEIGHT,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                color: 'hsl(' + Math.random() * 360 + ',80%,60%)',
                trail: []
            });
        }

        // ===== CLIENTS =====
        const clients = [
            { canvas: document.getElementById('client1'), x: 50, y: 50, color: 'cyan', keys: {}, buffer: {}, latency: 100, id: 'c1', trail: [], timeline: document.getElementById('timeline1') },
            { canvas: document.getElementById('client2'), x: 350, y: 350, color: 'orange', keys: {}, buffer: {}, latency: 100, id: 'c2', trail: [], timeline: document.getElementById('timeline2') }
        ];

        // ===== CONTROLS =====
        const latSlider1 = document.getElementById('latSlider1');
        const latSlider2 = document.getElementById('latSlider2');
        const latVal1 = document.getElementById('latVal1');
        const latVal2 = document.getElementById('latVal2');

        latSlider1.oninput = () => { clients[0].latency = parseInt(latSlider1.value); latVal1.textContent = latSlider1.value; }
        latSlider2.oninput = () => { clients[1].latency = parseInt(latSlider2.value); latVal2.textContent = latSlider2.value; }

        // ===== INPUT =====
        window.addEventListener('keydown', e => {
            if (['w', 'a', 's', 'd'].includes(e.key)) clients[0].keys[e.key] = true;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) clients[1].keys[e.key] = true;
        });
        window.addEventListener('keyup', e => {
            if (['w', 'a', 's', 'd'].includes(e.key)) clients[0].keys[e.key] = false;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) clients[1].keys[e.key] = false;
        });

        // ===== HELPERS =====
        function getCell(x, y) { return { cx: Math.floor(x / CELL_SIZE), cy: Math.floor(y / CELL_SIZE) }; }
        function distance(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }

        function getVisibleForClient(client) {
            const visible = [];
            entities.forEach(ent => {
                const dx = Math.abs(getCell(ent.x, ent.y).cx - getCell(client.x, client.y).cx);
                const dy = Math.abs(getCell(ent.x, ent.y).cy - getCell(client.x, client.y).cy);
                const inAOI = dx <= AOI_CELLS && dy <= AOI_CELLS;
                visible.push({ ...ent, inAOI });
            });
            clients.forEach(other => {
                if (other === client) return;
                const dx = Math.abs(getCell(other.x, other.y).cx - getCell(client.x, client.y).cx);
                const dy = Math.abs(getCell(other.x, other.y).cy - getCell(client.x, client.y).cy);
                const inAOI = dx <= AOI_CELLS && dy <= AOI_CELLS;
                visible.push({ id: other.id, x: other.x, y: other.y, color: other.color, inAOI });
            });
            return visible;
        }

        // ===== SERVER SIMULATION =====
        let tickCount = 0;
        function serverTick() {
            tickCount++;
            entities.forEach(ent => {
                ent.x += ent.vx;
                ent.y += ent.vy;
                if (ent.x < 0 || ent.x > WORLD_WIDTH) ent.vx *= -1;
                if (ent.y < 0 || ent.y > WORLD_HEIGHT) ent.vy *= -1;
            });
            clients.forEach(client => {
                const visible = getVisibleForClient(client);
                visible.forEach(obj => {
                    const latency = client.latency;
                    setTimeout(() => {
                        const prev = client.buffer[obj.id];
                        if (prev && (prev.x !== obj.x || prev.y !== obj.y)) {
                            obj.rollback = { from: { x: prev.x, y: prev.y }, to: { x: obj.x, y: obj.y }, frames: 10 };
                        }
                        client.buffer[obj.id] = { ...obj };
                        client.timeline.textContent = `Client ${client.id} Timeline: ${tickCount} | Buffer: ${Object.keys(client.buffer).length}`;
                    }, latency);
                });
            });
        }
        setInterval(serverTick, SERVER_TICK);

        // ===== DRAW CLIENT =====
        function drawClient(client) {
            const ctx = client.canvas.getContext('2d');
            ctx.clearRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

            // grid
            ctx.strokeStyle = '#444';
            for (let i = 0; i <= WORLD_WIDTH; i += CELL_SIZE) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, WORLD_HEIGHT); ctx.stroke(); }
            for (let i = 0; i <= WORLD_HEIGHT; i += CELL_SIZE) { ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(WORLD_WIDTH, i); ctx.stroke(); }

            // AOI boundary
            const cell = getCell(client.x, client.y);
            ctx.strokeStyle = 'yellow';
            ctx.lineWidth = 2;
            ctx.strokeRect(
                (cell.cx - AOI_CELLS) * CELL_SIZE,
                (cell.cy - AOI_CELLS) * CELL_SIZE,
                (AOI_CELLS * 2 + 1) * CELL_SIZE,
                (AOI_CELLS * 2 + 1) * CELL_SIZE
            );
            ctx.lineWidth = 1;

            // client trail
            client.trail.push({ x: client.x, y: client.y });
            if (client.trail.length > TRAIL_LENGTH) client.trail.shift();
            client.trail.forEach((pos, i) => {
                ctx.fillStyle = client.color + Math.floor(150 * (i / TRAIL_LENGTH)).toString(16).padStart(2, '0');
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
                ctx.fill();
            });

            // draw buffered entities + trails
            Object.values(client.buffer).forEach(ent => {
                if (!ent.trail) ent.trail = [];
                ent.trail.push({ x: ent.x, y: ent.y, rollback: ent.rollback ? true : false });
                if (ent.trail.length > TRAIL_LENGTH) ent.trail.shift();

                ent.trail.forEach((pos, i) => {
                    if (pos.rollback) {
                        ctx.fillStyle = `rgba(255,0,0,${(i + 1) / TRAIL_LENGTH})`;
                    } else {
                        ctx.fillStyle = (ent.inAOI ? ent.color : ent.color + '55') + Math.floor(150 * (i / TRAIL_LENGTH)).toString(16).padStart(2, '0');
                    }
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });

                // rollback line
                if (ent.rollback && ent.rollback.frames > 0) {
                    ctx.strokeStyle = 'rgba(255,0,0,0.7)';
                    ctx.beginPath();
                    ctx.moveTo(ent.rollback.from.x, ent.rollback.from.y);
                    ctx.lineTo(ent.rollback.to.x, ent.rollback.to.y);
                    ctx.stroke();
                    ent.rollback.frames--;

                    // mark last trail positions as rollback
                    ent.trail.slice(-3).forEach(t => t.rollback = true);
                }

                // entity head
                ctx.fillStyle = ent.inAOI ? ent.color : ent.color + '55';
                ctx.beginPath();
                ctx.arc(ent.x, ent.y, 8, 0, Math.PI * 2);
                ctx.fill();
            });

            // draw client head
            ctx.fillStyle = client.color;
            ctx.beginPath();
            ctx.arc(client.x, client.y, 10, 0, Math.PI * 2);
            ctx.fill();
        }

        // ===== UPDATE LOOP =====
        function update() {
            clients.forEach((c, i) => {
                if (i === 0) { // WASD
                    if (c.keys['w']) c.y -= 2;
                    if (c.keys['s']) c.y += 2;
                    if (c.keys['a']) c.x -= 2;
                    if (c.keys['d']) c.x += 2;
                } else { // Arrows
                    if (c.keys['ArrowUp']) c.y -= 2;
                    if (c.keys['ArrowDown']) c.y += 2;
                    if (c.keys['ArrowLeft']) c.x -= 2;
                    if (c.keys['ArrowRight']) c.x += 2;
                }
                c.x = Math.max(0, Math.min(WORLD_WIDTH, c.x));
                c.y = Math.max(0, Math.min(WORLD_HEIGHT, c.y));
                drawClient(c);
            });
            requestAnimationFrame(update);
        }
        update();
    </script>
</body>

</html>