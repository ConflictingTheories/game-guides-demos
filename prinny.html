<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DISGAEA DOOD DEMO — FINAL FINAL (100% VISIBLE)</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{background:#111;color:#eee;font-family:monospace;padding:20px}
    canvas{display:block;width:100%;max-width:800px;height:500px;margin:20px auto;border:2px solid #ff6b9d;border-radius:8px;background:#222}
    .controls{background:#222;padding:15px;border-radius:8px;margin:10px auto;max-width:800px}
    .status{font-weight:bold;color:#ff6b9d}
    kbd{background:#444;padding:3px 6px;border-radius:4px;font-size:11px}
    .prinny{font-size:36px;text-align:center;margin:20px;color:#ff6b9d;animation:pulse 1s infinite}
    @keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.2)}}
  </style>
</head>
<body>

  <h1 style="text-align:center;color:#ff6b9d">DISGAEA SRPG — DOOD DEMO</h1>
  <p style="text-align:center">Click unit → WASD move → L lift → T throw → G Geo → Space next</p>

  <canvas id="c"></canvas>

  <div class="controls">
    <p><strong>Status:</strong> <span id="status" class="status">Select a unit!</span></p>
  </div>

  <div class="prinny">PRINNY SQUAD DOOD!</div>

  <script>
    // === WEBGL2 SETUP ===
    const canvas = document.getElementById('c');
    const gl = canvas.getContext('webgl2');
    if (!gl) { alert('WebGL2 required!'); }

    canvas.width = 800; canvas.height = 500;
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.1, 0.1, 0.15, 1);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    // === SHADERS ===
    const vs = `#version 300 es
      in vec2 aPos;
      in vec3 aOffset;
      in vec4 aColor;
      uniform mat4 uMVP;
      out vec4 vColor;
      void main(){
        vec3 pos = vec3(aPos + aOffset.xy, aOffset.z);
        gl_Position = uMVP * vec4(pos, 1.0);
        vColor = aColor;
      }`;

    const fs = `#version 300 es
      precision mediump float;
      in vec4 vColor;
      out vec4 fragColor;
      void main(){ fragColor = vColor; }`;

    const program = gl.createProgram();
    const vShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vShader, vs);
    gl.compileShader(vShader);
    gl.attachShader(program, vShader);

    const fShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fShader, fs);
    gl.compileShader(fShader);
    gl.attachShader(program, fShader);

    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(program));
    }
    gl.useProgram(program);

    const loc = {
      pos: gl.getAttribLocation(program, 'aPos'),
      offset: gl.getAttribLocation(program, 'aOffset'),
      color: gl.getAttribLocation(program, 'aColor'),
      mvp: gl.getUniformLocation(program, 'uMVP')
    };

    // === QUAD VBO ===
    const quad = new Float32Array([-0.5,-0.5, 0.5,-0.5, -0.5,0.5, 0.5,-0.5, 0.5,0.5, -0.5,0.5]);
    const quadVBO = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
    gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);

    // === INSTANCE VBOs ===
    const instVBO = gl.createBuffer();
    const colVBO = gl.createBuffer();

    // === MATH ===
    function ortho(l,r,b,t,n,f){
      const m = new Float32Array(16);
      m[0]=2/(r-l); m[5]=2/(t-b); m[10]=-2/(f-n);
      m[12]=-(r+l)/(r-l); m[13]=-(t+b)/(t-b); m[14]=-(f+n)/(f-n); m[15]=1;
      return m;
    }

    function lookAt(eye, center, up){
      const f = [center[0]-eye[0], center[1]-eye[1], center[2]-eye[2]];
      const fl = Math.hypot(...f);
      const fn = [f[0]/fl, f[1]/fl, f[2]/fl];
      const s = [up[1]*fn[2]-up[2]*fn[1], up[2]*fn[0]-up[0]*fn[2], up[0]*fn[1]-up[1]*fn[0]];
      const sl = Math.hypot(...s);
      const sn = [s[0]/sl, s[1]/sl, s[2]/sl];
      const u = [fn[1]*sn[2]-fn[2]*sn[1], fn[2]*sn[0]-fn[0]*sn[2], fn[0]*sn[1]-fn[1]*sn[0]];
      const m = new Float32Array(16);
      m[0]=sn[0]; m[1]=u[0]; m[2]=-fn[0]; m[4]=sn[1]; m[5]=u[1]; m[6]=-fn[1];
      m[8]=sn[2]; m[9]=u[2]; m[10]=-fn[2];
      m[12]=-(sn[0]*eye[0]+sn[1]*eye[1]+sn[2]*eye[2]);
      m[13]=-(u[0]*eye[0]+u[1]*eye[1]+u[2]*eye[2]);
      m[14]=fn[0]*eye[0]+fn[1]*eye[1]+fn[2]*eye[2];
      m[15]=1;
      return m;
    }

    function rotY(a){
      const c=Math.cos(a), s=Math.sin(a);
      const m=new Float32Array(16);
      m[0]=c; m[2]=-s; m[5]=1; m[8]=s; m[10]=c; m[15]=1;
      return m;
    }

    function rotX(a){
      const c=Math.cos(a), s=Math.sin(a);
      const m=new Float32Array(16);
      m[0]=1; m[5]=c; m[6]=s; m[9]=-s; m[10]=c; m[15]=1;
      return m;
    }

    function mul(a,b){
      const o=new Float32Array(16);
      for(let i=0;i<4;i++)for(let j=0;j<4;j++)for(let k=0;k<4;k++)
        o[i*4+j] += a[i*4+k] * b[k*4+j];
      return o;
    }

    function getMVP(){
      const proj = ortho(-15,15,-9,9,0.1,100);
      const view = lookAt([7,15,7],[7,0,7],[0,1,0]);
      const ry = rotY(-Math.PI/4);
      const rx = rotX(-Math.PI/6);
      return mul(proj, mul(view, mul(ry, rx)));
    }

    // === GRID & UNITS ===
    const W=16, D=12;
    const grid = Array(W*D).fill().map(()=>({geo:0,unit:null}));

    class Unit{
      constructor(x,z,team,type){
        this.x=x;this.z=z;this.team=team;this.type=type;
        this.move=4;this.lifted=null;this.carrying=false;
        this.selected=false;this.visible=true;
        grid[x+z*W].unit=this;
      }
    }

    const units = [
      new Unit(4,4,0,0), // Hero
      new Unit(5,5,0,1), // Prinny
      new Unit(10,7,1,2), // Enemy
    ];

    // Geo Panels
    for(let x=7;x<10;x++)for(let z=6;z<9;z++) grid[x+z*W].geo=1;
    grid[8+7*W].geo=2; // Symbol

    let selected = null;

    // === INPUT ===
    const keys = {};
    window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

    canvas.addEventListener('click', e => {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) / canvas.width * 2 - 1;
      const y = 1 - (e.clientY - rect.top) / canvas.height * 2;
      const mvp = getMVP();
      const inv = invertMVP(mvp);
      const world = mul4(inv, [x, y, 0, 1]);
      const wx = world[0]/world[3] + 7;
      const wz = world[2]/world[3] + 7;
      const tx = Math.floor(wx + wz * 0.5);
      const tz = Math.floor(wz - wx * 0.5);
      if(tx>=0&&tx<W&&tz>=0&&tz<D){
        const cell = grid[tx+tz*W];
        if(cell.unit && cell.unit.team===0) selectUnit(cell.unit);
        else if(selected && selected.range && selected.range.includes(tx+tz*W)) moveUnit(selected, tx, tz);
      }
    });

    function invertMVP(m){
      // Simplified inverse for ortho + rotation + translation
      const inv = new Float32Array(16);
      for(let i=0;i<3;i++)for(let j=0;j<3;j++) inv[i*4+j] = m[j*4+i];
      inv[15]=1;
      const trans = [m[12], m[13], m[14]];
      inv[12] = -(inv[0]*trans[0] + inv[4]*trans[1] + inv[8]*trans[2]);
      inv[13] = -(inv[1]*trans[0] + inv[5]*trans[1] + inv[9]*trans[2]);
      inv[14] = -(inv[2]*trans[0] + inv[6]*trans[1] + inv[10]*trans[2]);
      return inv;
    }

    function mul4(m,v){
      const o=[0,0,0,0];
      for(let i=0;i<4;i++)for(let j=0;j<4;j++) o[i]+=m[i*4+j]*v[j];
      return o;
    }

    function selectUnit(u){
      if(selected) selected.selected = false;
      selected = u; u.selected = true;
      computeRange(u);
      status(`Selected ${u.type===1?'PRINNY':'UNIT'}!`);
    }

    function computeRange(u){
      u.range = [];
      const q = [{x:u.x,z:u.z,c:0}];
      const vis = new Set([u.x+u.z*W]);
      while(q.length){
        const cur = q.shift();
        if(cur.c>0) u.range.push(cur.x+cur.z*W);
        if(cur.c>=u.move) continue;
        const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
        for(const [dx,dz] of dirs){
          const nx=cur.x+dx, nz=cur.z+dz, ni=nx+nz*W;
          if(nx>=0&&nx<W&&nz>=0&&nz<D&&!vis.has(ni)&&(grid[ni].unit===null||grid[ni].unit===u)){
            vis.add(ni);
            q.push({x:nx,z:nz,c:cur.c+1});
          }
        }
      }
    }

    function moveUnit(u,x,z){
      grid[u.x+u.z*W].unit = null;
      u.x = x; u.z = z;
      grid[x+z*W].unit = u;
      u.range = [];
      status('Moved! L=lift T=throw');
    }

    function status(t){ document.getElementById('status').textContent = t; }

    // Key actions
    setInterval(()=>{
      if(!selected) return;
      const dir={w:[0,-1],s:[0,1],a:[-1,0],d:[1,0]};
      for(const [k,[dx,dz]] of Object.entries(dir)){
        if(keys[k]){
          const nx=selected.x+dx, nz=selected.z+dz, ni=nx+nz*W;
          if(nx>=0&&nx<W&&nz>=0&&nz<D&&selected.range.includes(ni)){
            moveUnit(selected,nx,nz);
            keys[k]=false;
            break;
          }
        }
      }
    },160);

    window.addEventListener('keydown', e=>{
      if(!selected) return;
      const k = e.key.toLowerCase();
      if(k==='l' && !selected.carrying){
        const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
        for(const [dx,dz] of dirs){
          const tx=selected.x+dx, tz=selected.z+dz, ti=tx+tz*W;
          if(tx>=0&&tx<W&&tz>=0&&tz<D && grid[ti].unit && grid[ti].unit.team!==selected.team){
            selected.carrying=true;
            selected.lifted=grid[ti].unit;
            selected.lifted.visible=false;
            grid[ti].unit=null;
            status('LIFTED! T=throw');
            break;
          }
        }
      }
      if(k==='t' && selected.carrying){
        const tx=selected.x+Math.floor(Math.random()*5)-2;
        const tz=selected.z+Math.floor(Math.random()*5)-2;
        const ti=tx+tz*W;
        if(tx>=0&&tx<W&&tz>=0&&tz<D && !grid[ti].unit){
          const l=selected.lifted;
          l.x=tx; l.z=tz; l.visible=true;
          grid[ti].unit=l;
          selected.carrying=false; selected.lifted=null;
          status('THROWN DOOD!');
          if(l.type===1) explode();
        }
      }
      if(k==='g'){
        const sym=8+7*W;
        if(grid[sym].geo===2){
          for(let i=0;i<grid.length;i++){
            if(grid[i].geo===1){
              grid[i].geo=0;
              if(grid[i].unit) grid[i].unit.hp-=50;
            }
          }
          grid[sym].geo=0;
          status('GEO CHAIN DOOD!');
        }
      }
      if(k===' '){ if(selected) selected.selected=false; selected=null; status('Next turn!'); }
    });

    function explode(){
      const p=document.querySelector('.prinny');
      p.textContent='DOOD!!! BOOM!';
      p.style.color='#ff0000';
      setTimeout(()=>{ p.textContent='PRINNY SQUAD DOOD!'; p.style.color='#ff6b9d'; },1000);
    }

    // === RENDER LOOP ===
    function render(){
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      const mvp = getMVP();
      gl.uniformMatrix4fv(loc.mvp, false, mvp);

      const max = W*D*3;
      const inst = new Float32Array(max*3);
      const col = new Float32Array(max*4);
      let cnt = 0;

      // Grid
      for(let x=0;x<W;x++)for(let z=0;z<D;z++){
        const wx = (x - z) * 0.5 - 4;
        const wz = (x + z) * 0.5 - 3;
        const c = grid[x+z*W].geo===1?[1,0,0,0.7]:grid[x+z*W].geo===2?[0,0,1,0.9]:[0.2,0.2,0.25,0.9];
        inst[cnt*3]=wx; inst[cnt*3+1]=0; inst[cnt*3+2]=wz;
        col[cnt*4]=c[0]; col[cnt*4+1]=c[1]; col[cnt*4+2]=c[2]; col[cnt*4+3]=c[3];
        cnt++;
      }

      // Range
      if(selected && selected.range){
        for(const i of selected.range){
          const x=i%W, z=Math.floor(i/W);
          const wx = (x - z) * 0.5 - 4;
          const wz = (x + z) * 0.5 - 3;
          inst[cnt*3]=wx; inst[cnt*3+1]=0.05; inst[cnt*3+2]=wz;
          col[cnt*4]=0; col[cnt*4+1]=1; col[cnt*4+2]=1; col[cnt*4+3]=0.4;
          cnt++;
        }
      }

      // Units
      for(const u of units){
        if(!u.visible) continue;
        const wx = (u.x - u.z) * 0.5 - 4;
        const wz = (u.x + u.z) * 0.5 - 3;
        const h = u.carrying?1.4:0.7;
        let c = u.team===0?[0,1,1,1]:u.type===1?[1,0.8,0,1]:[1,0,0,1];
        if(u.selected) c[3] = 0.7 + Math.sin(Date.now()*0.008)*0.3;
        inst[cnt*3]=wx; inst[cnt*3+1]=h; inst[cnt*3+2]=wz;
        col[cnt*4]=c[0]; col[cnt*4+1]=c[1]; col[cnt*4+2]=c[2]; col[cnt*4+3]=c[3];
        cnt++;
      }

      // Upload
      gl.bindBuffer(gl.ARRAY_BUFFER, instVBO);
      gl.bufferData(gl.ARRAY_BUFFER, inst.subarray(0, cnt*3), gl.DYNAMIC_DRAW);
      gl.vertexAttribPointer(loc.offset, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(loc.offset);
      gl.vertexAttribDivisor(loc.offset, 1);

      gl.bindBuffer(gl.ARRAY_BUFFER, colVBO);
      gl.bufferData(gl.ARRAY_BUFFER, col.subarray(0, cnt*4), gl.DYNAMIC_DRAW);
      gl.vertexAttribPointer(loc.color, 4, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(loc.color);
      gl.vertexAttribDivisor(loc.color, 1);

      gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
      gl.vertexAttribPointer(loc.pos, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(loc.pos);

      gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, cnt);

      requestAnimationFrame(render);
    }

    render();
  </script>

</body>
</html>