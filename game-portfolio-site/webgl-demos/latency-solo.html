<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Rollback Demo</title>
    <style>
        canvas {
            background: #111;
            display: block;
            margin: 0 auto;
        }

        #ui {
            text-align: center;
            margin-top: 10px;
            color: white;
            font-family: sans-serif;
        }
    </style>
</head>

<body>
    <canvas id="game" width="600" height="400"></canvas>
    <div id="ui">
        Latency: <input type="range" id="latency" min="0" max="300" value="100"> <span id="latencyVal">100</span> ms
    </div>
    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const latencySlider = document.getElementById('latency');
        const latencyVal = document.getElementById('latencyVal');

        latencySlider.oninput = () => latencyVal.innerText = latencySlider.value;

        const keys = {};
        document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        const tickRate = 60;
        const serverTickRate = 30; // simulate server
        const dt = 1 / tickRate;

        let player = { x: 100, y: 100 };
        let predictedPlayer = { x: 100, y: 100 };
        let serverPlayer = { x: 100, y: 100 };
        let latencyQueue = [];

        function move(p, dt) {
            const speed = 150; // px/sec
            if (keys['w'] || keys['arrowup']) p.y -= speed * dt;
            if (keys['s'] || keys['arrowdown']) p.y += speed * dt;
            if (keys['a'] || keys['arrowleft']) p.x -= speed * dt;
            if (keys['d'] || keys['arrowright']) p.x += speed * dt;
        }

        function gameTick() {
            move(predictedPlayer, dt);

            // Simulate sending move to server with latency
            const latency = parseInt(latencySlider.value);
            latencyQueue.push({ x: predictedPlayer.x, y: predictedPlayer.y, sendTime: Date.now(), latency });

            // Process server updates
            const now = Date.now();
            latencyQueue.forEach((msg, idx) => {
                if (now - msg.sendTime >= msg.latency) {
                    serverPlayer.x = msg.x;
                    serverPlayer.y = msg.y;
                    latencyQueue.splice(idx, 1);
                }
            });

            // Rollback correction
            const correction = 0.2;
            predictedPlayer.x += (serverPlayer.x - predictedPlayer.x) * correction;
            predictedPlayer.y += (serverPlayer.y - predictedPlayer.y) * correction;

            draw();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Predicted player
            ctx.fillStyle = 'cyan';
            ctx.fillRect(predictedPlayer.x - 10, predictedPlayer.y - 10, 20, 20);

            // Server ghost
            ctx.fillStyle = 'red';
            ctx.globalAlpha = 0.5;
            ctx.fillRect(serverPlayer.x - 10, serverPlayer.y - 10, 20, 20);
            ctx.globalAlpha = 1.0;
        }

        setInterval(gameTick, 1000 / tickRate);
    </script>
</body>

</html>