<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebGL to OpenGL C++ Translation Guide</title>
  <link rel="stylesheet" href="guide-style.css" />
  <!-- Mermaid -->
  <script src="/lib/mermaid.min.js"></script>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: 'dark',
      securityLevel: 'loose',
      flowchart: { useMaxWidth: true, htmlLabels: true }
    });
  </script>
</head>

<body>
  <header>
    <h1>WebGL to OpenGL C++ Translation Guide</h1>
    <p class="note">This guide explains how to translate WebGL (JavaScript) code to native OpenGL in C++. Click topics
      to filter sections. WebGL is based on OpenGL ES 2.0/3.0, so most calls map directly, but desktop OpenGL offers
      more features. Use Emscripten for hybrid C++-to-WebGL compilation if needed.<grok-card data-id="ee6d11"
        data-type="citation_card"></grok-card><grok-card data-id="c8e40c" data-type="citation_card"></grok-card></p>

    <div class="toc">
      <div class="chip" data-section="all">Show All</div>
      <div class="chip active" data-section="overview">Overview</div>
      <div class="chip" data-section="setup">Setup & Context</div>
      <div class="chip" data-section="shaders">Shaders</div>
      <div class="chip" data-section="buffers">Buffers & Attributes</div>
      <div class="chip" data-section="textures">Textures</div>
      <div class="chip" data-section="drawing">Drawing & States</div>
      <div class="chip" data-section="advanced">Advanced Topics</div>
      <div class="chip" data-section="emscripten">Emscripten Hybrid</div>
    </div>
  </header>

  <button id="show-all-btn">Show All Sections</button>

  <!-- Overview -->
  <section id="overview" class="section active">
    <h2>Overview</h2>
    <div class="row">
      <div class="col">
        <p>WebGL (JS) to OpenGL (C++): WebGL calls mirror OpenGL ES, but in JS. In C++, use
          <code>#include &lt;GL/glew.h&gt;</code> or <code>#include &lt;GLFW/glfw3.h&gt;</code> for core profile. Key
          differences: No fixed-function pipeline (use shaders), error handling via <code>glGetError()</code>, and
          manual context management.</p>
        <div class="tip"><strong>Tip:</strong> Start with OpenGL 3.3+ core for modern features. WebGL 2.0 ≈ OpenGL ES
          3.0.<grok-card data-id="e017b0" data-type="citation_card"></grok-card></div>
        <div class="diagram">
          <div class="mermaid">
            graph TD
            JS[WebGL JS] -->|API Calls| GPU[GPU]
            CPP[OpenGL C++] -->|Native Calls| GPU
            JS -->|Emscripten| CPP
            classDef web fill:#f66
            class JS web
          </div>
        </div>
      </div>
      <div class="col">
        <h3>Common Mapping Strategy</h3>
        <ul>
          <li>Replace <code>getContext('webgl')</code> with GLFW/GLAD setup.</li>
          <li>JS <code>gl.uniform1f()</code> → C++ <code>glUniform1f()</code>.</li>
          <li>Handle JS callbacks (e.g., animation loop) with C++ <code>while(!glfwWindowShouldClose())</code>.</li>
        </ul>
        <div class="tip"><strong>Pro Insight:</strong> Use RAII wrappers for resources (e.g., smart pointers for
          buffers) to avoid leaks.<grok-card data-id="e7eb4a" data-type="citation_card"></grok-card></div>
      </div>
    </div>
  </section>

  <!-- Setup -->
  <section id="setup" class="section">
    <h2>Setup & Context Creation</h2>
    <div class="row">
      <div class="col">
        <h3>WebGL (JS)</h3>
        <pre>const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');</pre>
        <h3>OpenGL (C++)</h3>
        <pre>#include &lt;GL/glew.h&gt;
#include &lt;GLFW/glfw3.h&gt;

GLFWwindow* window;
if (!glfwInit()) { /* error */ }
glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
window = glfwCreateWindow(800, 600, "OpenGL", NULL, NULL);
glfwMakeContextCurrent(window);
glewInit();</pre>
        <div class="tip"><strong>Tip:</strong> For WebGL 1.0 compat, use OpenGL 2.1. GLEW loads extensions; GLFW handles
          windowing.<grok-card data-id="d23f2b" data-type="citation_card"></grok-card></div>
      </div>
      <div class="col">
        <div class="diagram">
          <div class="mermaid">
            sequenceDiagram
            JS: getContext('webgl')
            JS->>+GPU: Create Context
            C: glfwCreateWindow()
            C->>+GPU: Native Context
            Note over JS,C: Similar but JS is sandboxed
          </div>
        </div>
        <p class="note">C++ requires explicit version hints; JS auto-negotiates.</p>
      </div>
    </div>
  </section>

  <!-- Shaders -->
  <section id="shaders" class="section">
    <h2>Shaders & Programs</h2>
    <div class="row">
      <div class="col">
        <h3>Shader Compilation (Common)</h3>
        <p>GLSL is nearly identical; WebGL uses GLSL ES (add <code>#version 300 es</code> for WebGL 2).</p>
        <h3>WebGL (JS)</h3>
        <pre>const vsSource = `#ifdef GL_ES\nprecision mediump float;\n#endif\nattribute vec4 aVertexPosition;\nvoid main() { gl_Position = aVertexPosition; }`;
const vs = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vs, vsSource);
gl.compileShader(vs);</pre>
        <h3>OpenGL (C++)</h3>
        <pre>const char* vsSource = R"(#version 330 core
layout (location = 0) in vec4 aVertexPosition;
void main() { gl_Position = aVertexPosition; })";
GLuint vs = glCreateShader(GL_VERTEX_SHADER);
glShaderSource(vs, 1, &vsSource, NULL);
glCompileShader(vs);</pre>
      </div>
      <div class="col">
        <h3>Program Linking</h3>
        <p>WebGL: <code>gl.attachShader(), gl.linkProgram()</code>. C++: Same functions.</p>
        <div class="tip"><strong>Check Errors:</strong> Use
          <code>glGetShaderiv(shader, GL_COMPILE_STATUS, &success)</code> in both.<grok-card data-id="eeb946"
            data-type="citation_card"></grok-card></div>
        <table>
          <tr>
            <th>WebGL/JS</th>
            <th>OpenGL/C++</th>
          </tr>
          <tr>
            <td><code>gl.getUniformLocation(program, 'u_color')</code></td>
            <td><code>glGetUniformLocation(program, "u_color")</code></td>
          </tr>
          <tr>
            <td><code>gl.uniform4fv(loc, color)</code></td>
            <td><code>glUniform4fv(loc, 1, color)</code></td>
          </tr>
        </table>
      </div>
    </div>
  </section>

  <!-- Buffers -->
  <section id="buffers" class="section">
    <h2>Buffers & Attributes</h2>
    <div class="row">
      <div class="col">
        <h3>Vertex Buffer</h3>
        <h3>WebGL (JS)</h3>
        <pre>const positions = new Float32Array([0,0, 1,0, 0,1]);
const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);</pre>
        <h3>OpenGL (C++)</h3>
        <pre>float positions[] = {0,0, 1,0, 0,1};
GLuint buffer;
glGenBuffers(1, &buffer);
glBindBuffer(GL_ARRAY_BUFFER, buffer);
glBufferData(GL_ARRAY_BUFFER, sizeof(positions), positions, GL_STATIC_DRAW);</pre>
      </div>
      <div class="col">
        <h3>Attributes</h3>
        <p>WebGL: <code>gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);</code>
        </p>
        <p>C++: Identical, but use <code>glVertexAttribPointer()</code>.</p>
        <div class="tip"><strong>Pro Tip:</strong> Use VAOs in OpenGL for state encapsulation:
          <code>glGenVertexArrays(1, &vao); glBindVertexArray(vao);</code>. WebGL 1 lacks VAOs (use extension in WebGL
          2).<grok-card data-id="37badc" data-type="citation_card"></grok-card></div>
        <div class="diagram">
          <div class="mermaid">
            graph TD
            Data[Vertex Data] --> Buffer[glBufferData]
            Buffer --> VBO[VBO]
            VBO --> Attr[glVertexAttribPointer]
            Attr --> Draw[glDrawArrays]
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Textures -->
  <section id="textures" class="section">
    <h2>Textures & Samplers</h2>
    <div class="row">
      <div class="col">
        <h3>Basic Texture Load</h3>
        <h3>WebGL (JS)</h3>
        <pre>const texture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, img.width, img.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, img);
gl.generateMipmap(gl.TEXTURE_2D);</pre>
        <h3>OpenGL (C++)</h3>
        <pre>GLuint texture;
glGenTextures(1, &texture);
glBindTexture(GL_TEXTURE_2D, texture);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
glGenerateMipmap(GL_TEXTURE_2D);</pre>
      </div>
      <div class="col">
        <table>
          <tr>
            <th>Aspect</th>
            <th>WebGL/JS</th>
            <th>OpenGL/C++</th>
          </tr>
          <tr>
            <td>Bind</td>
            <td><code>gl.bindTexture(target, tex)</code></td>
            <td><code>glBindTexture(target, tex)</code></td>
          </tr>
          <tr>
            <td>Params</td>
            <td><code>gl.texParameteri(target, prop, val)</code></td>
            <td><code>glTexParameteri(target, prop, val)</code></td>
          </tr>
          <tr>
            <td>Active</td>
            <td><code>gl.activeTexture(gl.TEXTURE0)</code></td>
            <td><code>glActiveTexture(GL_TEXTURE0)</code></td>
          </tr>
        </table>
        <div class="tip"><strong>Note:</strong> OpenGL supports more formats (e.g., compressed textures); check enums
          like <code>GL_COMPRESSED_RGB_S3TC_DXT1_EXT</code>.<grok-card data-id="0a2ce9"
            data-type="citation_card"></grok-card></div>
      </div>
    </div>
  </section>

  <!-- Drawing -->
  <section id="drawing" class="section">
    <h2>Drawing & State Management</h2>
    <div class="row">
      <div class="col">
        <h3>Render Loop</h3>
        <h3>WebGL (JS)</h3>
        <pre>function render() {
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.drawArrays(gl.TRIANGLES, 0, 3);
  requestAnimationFrame(render);
}</pre>
        <h3>OpenGL (C++)</h3>
        <pre>while (!glfwWindowShouldClose(window)) {
  glClear(GL_COLOR_BUFFER_BIT);
  glDrawArrays(GL_TRIANGLES, 0, 3);
  glfwSwapBuffers(window);
  glfwPollEvents();
}</pre>
      </div>
      <div class="col">
        <h3>State Changes</h3>
        <p>Both use <code>glUseProgram(), glEnable(GL_DEPTH_TEST)</code>. OpenGL has more states (e.g.,
          <code>glBlendFunc()</code>).</p>
        <div class="tip"><strong>Error Handling:</strong> Wrap calls in
          <code>GLenum err; while((err=glGetError()) != GL_NO_ERROR) { /* log */ }</code> for debugging.<grok-card
            data-id="426807" data-type="citation_card"></grok-card></div>
        <div class="diagram">
          <div class="mermaid">
            sequenceDiagram
            JS: requestAnimationFrame
            JS->>GPU: drawArrays
            C: glfwPollEvents
            C->>GPU: DrawArrays
            Note over JS,C: C++ more control over loop
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Advanced -->
  <section id="advanced" class="section">
    <h2>Advanced Topics</h2>
    <div class="row">
      <div class="col">
        <h3>Framebuffers & Offscreen</h3>
        <p>WebGL: <code>gl.createFramebuffer(), gl.bindFramebuffer(gl.FRAMEBUFFER, fb)</code>. C++: Identical.</p>
        <h3>Uniform Buffers</h3>
        <p>OpenGL supports UBOs natively; WebGL 2 via extension.</p>
        <div class="tip"><strong>Perf:</strong> Minimize state changes; batch draws. OpenGL faster without JS
          overhead.<grok-card data-id="f0e554" data-type="citation_card"></grok-card></div>
      </div>
      <div class="col">
        <h3>Extensions</h3>
        <table>
          <tr>
            <th>Feature</th>
            <th>WebGL</th>
            <th>OpenGL</th>
          </tr>
          <tr>
            <td>Instancing</td>
            <td>Extension</td>
            <td>Native (glDrawArraysInstanced)</td>
          </tr>
          <tr>
            <td>Compute Shaders</td>
            <td>WebGL 2 partial</td>
            <td>4.3+</td>
          </tr>
          <tr>
            <td>Debug Output</td>
            <td>Extension</td>
            <td>Native (glDebugMessageCallback)</td>
          </tr>
        </table>
      </div>
    </div>
  </section>

  <!-- Emscripten -->
  <section id="emscripten" class="section">
    <h2>Hybrid: Emscripten for C++ to WebGL</h2>
    <div class="row">
      <div class="col">
        <p>Compile C++ OpenGL to WASM/JS: <code>emcc main.cpp -s USE_WEBGL2=1 -s FULL_ES3=1 -o out.html</code>. Maps
          <code>gl*()</code> to WebGL automatically.<grok-card data-id="ec5a60"
            data-type="citation_card"></grok-card><grok-card data-id="ebf33f" data-type="citation_card"></grok-card></p>
        <pre>emcc -std=c++11 -O3 main.cpp -o webgl.html \
  -s USE_GLFW=3 -s FULL_ES3=1 \
  --preload-file assets/</pre>
        <div class="tip"><strong>Case Study:</strong> Port es2gears to Web via Emscripten—direct OpenGL calls become
          WebGL.<grok-card data-id="74b369" data-type="citation_card"></grok-card></div>
      </div>
      <div class="col">
        <div class="diagram">
          <div class="mermaid">
            graph TD
            CPP[OpenGL C++] --> Emc[Emscripten]
            Emc --> JS[WebGL JS/WASM]
            JS --> Browser[Browser]
            classDef tool fill:#022
            class Emc tool
          </div>
        </div>
        <p class="note">Ideal for cross-platform: Same code for desktop C++ and web.<grok-card data-id="d94751"
            data-type="citation_card"></grok-card></p>
      </div>
    </div>
  </section>

  <footer>
    <p>Pragmatic guide for translating WebGL to native OpenGL C++. Adapt for your project. Sources cited
      inline.<grok-card data-id="eaae5e" data-type="citation_card"></grok-card><grok-card data-id="81b191"
        data-type="citation_card"></grok-card></p>
  </footer>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const chips = document.querySelectorAll('.chip');
      const sections = document.querySelectorAll('.section');
      const showAllBtn = document.getElementById('show-all-btn');

      function showSection(id) {
        sections.forEach(sec => sec.classList.toggle('active', id === 'all' || sec.id === id));
        chips.forEach(chip => chip.classList.toggle('active', chip.dataset.section === id || id === 'all'));
      }

      chips.forEach(chip => chip.addEventListener('click', () => showSection(chip.dataset.section)));
      showAllBtn.addEventListener('click', () => showSection('all'));
    });
  </script>

</body>

</html>