<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2.5D-HD Octopath Traveler Engine — WebGL 2.0 & OpenGL C++</title>
  <link rel="stylesheet" href="guide-style.css" />
  <style>
    .octo {
      background: rgba(100, 200, 255, 0.1);
      border-left: 3px solid #64c8ff;
      padding: 10px;
      margin: 10px 0
    }
  </style>
  <!-- Mermaid -->
  <script src="/lib/mermaid.min.js"></script>
  <script>
    mermaid.initialize({
      startOnLoad: true: true,
      theme: 'dark',
      securityLevel: 'loose',
      flowchart: { useMaxWidth: true, htmlLabels: true }
    });
  </script>
</head>

<body>
  <header>
    <h1>2.5D-HD Engine — Octopath Traveler Style</h1>
    <p class="note">Complete system design for <strong>WebGL 2.0</strong> and <strong>OpenGL C++</strong>. Covers:
      isometric tiles, depth sorting, billboarding, jumping, collision, picking, and <strong>1000+ sprites at 60
        FPS</strong>.</p>

    <div class="toc">
      <div class="chip active" data-section="all">Show All</div>
      <div class="chip" data-section="overview">Overview</div>
      <div class="chip" data-section="camera">Camera & Projection</div>
      <div class="chip" data-section="tiles">Tilemap & Layers</div>
      <div class="chip" data-section="sprites">Sprites & Billboarding</div>
      <div class="chip" data-section="depth">Depth & Sorting</div>
      <div class="chip" data-section="collision">Collision & Picking</div>
      <div class="chip" data-section="jumping">Jumping & Corners</div>
      <div class="chip" data-section="perf">Performance</div>
    </div>
  </header>

  <button id="show-all-btn">Show All Sections</button>

  <!-- OVERVIEW -->
  <section id="overview" class="section active">
    <h2>Overview: 2.5D-HD Architecture</h2>
    <div class="row">
      <div class="col">
        <div class="octo"><strong>Octopath Core:</strong> 2D sprites in 3D space with <strong>orthographic isometric
            camera</strong>, <strong>Z-depth sorting</strong>, and <strong>billboarded sprites</strong> facing camera.
        </div>
        <div class="diagram">
          <div class="mermaid">
            graph TD
            Input[Input] --> Update[Update Logic]
            Update --> Sort[Sort by Z]
            Sort --> Render[Render Pass]
            Render --> GPU[GPU]
            classDef core fill:#022,stroke:#0f0
            class Update,Sort,Render core
          </div>
        </div>
      </div>
      <div class="col">
        <h3>Key Systems</h3>
        <ul>
          <li><strong>Tilemap:</strong> 2D grid → 3D positions</li>
          <li><strong>Camera:</strong> Fixed 30° isometric</li>
          <li><strong>Depth:</strong> Y + Z + layer offset</li>
          <li><strong>Billboarding:</strong> Sprites always face camera</li>
          <li><strong>Jumping:</strong> Z-offset + shadow</li>
        </ul>
      </div>
    </div>
  </section>

  <!-- CAMERA -->
  <section id="camera" class="section">
    <h2>Camera & Projection</h2>
    <div class="row">
      <div class="col">
        <h3>Isometric Orthographic</h3>
        <pre>// WebGL 2.0 / OpenGL
mat4 proj = ortho(-w/2, w/2, -h/2, h/2, 0.1, 1000);
mat4 view = lookAt(
  vec3(x, y + 20, z + 20),  // eye
  vec3(x, 0, z),            // center
  vec3(0, 1, 0)             // up
);
mat4 rot = rotateX(radians(-30)) * rotateY(radians(-45));
mat4 mvp = proj * view * rot;</pre>
        <div class="tip">Fixed 30° down, 45° rotation → classic isometric.</div>
      </div>
      <div class="col">
        <div class="diagram">
          <div class="mermaid">
            graph TD
            Eye[Camera Eye] -->|30° Down| Center[Ground Center]
            Center -->|45° Yaw| Rot[Isometric View]
            Rot --> Proj[Ortho Projection]
            Proj --> MVP[MVP Matrix]
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- TILEMAP -->
  <section id="tiles" class="section">
    <h2>Tilemap & Layers</h2>
    <div class="row">
      <div class="col">
        <h3>Tile to World Position</h3>
        <pre>// (tileX, tileY) → world (x, y, z)
float isoX = (tileX - tileY) * TILE_W / 2;
float isoZ = (tileX + tileY) * TILE_H / 2;
float worldY = tileY * 0.1; // slight slope
vec3 pos = vec3(isoX, worldY, isoZ);</pre>
        <div class="octo"><strong>Octopath:</strong> Uses <strong>3 layers</strong>: Ground, Mid, Top. Each with
          Z-offset.</div>
      </div>
      <div class="col">
        <div class="diagram">
          <div class="mermaid">
            graph LR
            Grid[2D Grid] -->|Stagger| Iso[Isometric Coords]
            Iso --> Layer1[Layer 0: Ground]
            Iso --> Layer2[Layer 1: Mid]
            Iso --> Layer3[Layer 2: Top]
            Layer1 --> Z0[Z = 0]
            Layer2 --> Z1[Z = 0.1]
            Layer3 --> Z2[Z = 0.2]
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- SPRITES -->
  <section id="sprites" class="section">
    <h2>Sprite Billboarding & Facing</h2>
    <div class="row">
      <div class="col">
        <h3>Billboard Matrix (Always Face Camera)</h3>
        <pre>// In vertex shader
mat4 billboard = mat4(
  view[0][0], view[1][0], view[2][0], 0,
  view[0][1], view[1][1], view[2][1], 0,
  view[0][2], view[1][2], view[2][2], 0,
  0, 0, 0, 1
);
gl_Position = mvp * billboard * vec4(localPos, 1.0);</pre>
        <div class="tip">Only rotate around Y? Use <code>mat3(view)</code> and preserve Y-up.</div>
      </div>
      <div class="col">
        <h3>Directional Sprites (8-dir)</h3>
        <pre>// UV offset based on direction
int dir = facing; // 0–7
float u = (dir % 4) * 0.25;
float v = (dir / 4) * 0.5;</pre>
        <div class="diagram">
          <div class="mermaid">
            graph TD
            Dir[Facing Dir] --> UV[UV Atlas Offset]
            UV --> Sprite[Sprite Sheet]
            Sprite --> Quad[Billboard Quad]
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- DEPTH -->
  <section id="depth" class="section">
    <h2>Depth Sorting & Clipping</h2>
    <div class="row">
      <div class="col">
        <h3>Z-Depth Formula</h3>
        <pre>float depth = 
  worldPos.y * 0.1 +    // slope
  worldPos.z * 0.01 +   // forward
  layer * 10.0 +        // layer priority
  isJumping ? 100 : 0;  // jump on top</pre>
        <div class="octo"><strong>Octopath:</strong> Characters behind walls? Use <strong>stencil buffer</strong> or
          <strong>alpha masking</strong>.
        </div>
      </div>
      <div class="col">
        <h3>Dynamic Sorting</h3>
        <pre>sprites.sort((a,b) => a.depth - b.depth);
// Then draw in order</pre>
        <div class="perf"><strong>Perf:</strong> Sort only when needed (dirty flag). Use <strong>instancing</strong> for
          static tiles.</div>
      </div>
    </div>
  </section>

  <!-- COLLISION -->
  <section id="collision" class="section">
    <h2>Collision & Object Picking</h2>
    <div class="row">
      <div class="col">
        <h3>Grid-Based Collision</h3>
        <pre>bool isWalkable(int tileX, int tileY, int layer) {
  return collisionMap[layer][tileY * width + tileX] == 0;
}</pre>
        <div class="tip">Use <strong>bitflags</strong>: walkable, water, cliff, event.</div>
      </div>
      <div class="col">
        <h3>Mouse Picking</h3>
        <pre>// Screen → World
vec2 ndc = (mousePos / viewport) * 2.0 - 1.0;
vec4 world = inverse(mvp) * vec4(ndc, -1, 1);
vec3 pos = world.xyz / world.w;

// Snap to grid
int tileX = floor(pos.x / TILE_W + pos.z / TILE_W);
int tileY = floor(pos.z / TILE_H - pos.x / TILE_W);</pre>
        <div class="diagram">
          <div class="mermaid">
            graph TD
            Mouse[Mouse] --> NDC[NDC]
            NDC --> Unproj[Unproject]
            Unproj --> Grid[Snap to Tile]
            Grid --> Pick[Select Object]
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- JUMPING -->
  <section id="jumping" class="section">
    <h2>Jumping, Corners & Elevation</h2>
    <div class="row">
      <div class="col">
        <h3>Jump Arc</h3>
        <pre>float t = jumpTime / jumpDuration;
float height = sin(t * PI) * jumpHeight;
entity.pos.y += height;
entity.depth += height * 10; // appear above</pre>
        <div class="tip">Draw <strong>shadow</strong> at ground level, billboarded.</div>
      </div>
      <div class="col">
        <h3>Corner Navigation</h3>
        <pre>// Allow diagonal move if both tiles walkable
if (isWalkable(tx+1,ty) && isWalkable(tx,ty+1)) {
  moveDiagonal();
}</pre>
        <div class="octo"><strong>Octopath:</strong> Uses <strong>pathfinding with corner rules</strong> and
          <strong>elevation checks</strong>.
        </div>
      </div>
    </div>
  </section>

  <!-- PERFORMANCE -->
  <section id="perf" class="section">
    <h2>Performance: 1000+ Sprites @ 60 FPS</h2>
    <div class="row">
      <div class="col">
        <h3>Instanced Tilemap</h3>
        <pre>// One draw call for all ground tiles
glDrawElementsInstanced(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, 0, tileCount);</pre>
        <div class="perf"><strong>Key:</strong> Instance buffer: <code>vec4(pos.x, pos.y, pos.z, tileID)</code></div>
      </div>
      <div class="col">
        <h3>Sprite Batching</h3>
        <pre>// Batch dynamic sprites by texture
for (texture in spriteAtlas) {
  bindTexture(texture);
  drawInstanced(spriteList[texture]);
}</pre>
        <div class="perf"><strong>Target:</strong>
          < 100 draw calls, < 1 MB upload/frame.</div>
            <div class="diagram">
              <div class="mermaid">
                graph TD
                Tiles[Static Tiles] --> Instanced[Instanced Draw]
                Sprites[Dynamic Sprites] --> Batch[Batch by Texture]
                Batch --> GPU[GPU]
                classDef fast fill:#050,stroke:#0f0
                class Instanced,Batch fast
              </div>
            </div>
        </div>
      </div>
  </section>

  <footer>
    <p>Complete 2.5D-HD engine design. Works in <strong>WebGL 2.0</strong> and <strong>OpenGL 3.3+</strong>. Ready for
      production.</p>
    <p>— Build beautiful, performant JRPGs. Like Octopath. But yours.</p>
  </footer>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const chips = document.querySelectorAll('.chip');
      const sections = document.querySelectorAll('.section');
      const showAllBtn = document.getElementById('show-all-btn');

      function showSection(id) {
        sections.forEach(sec => sec.classList.toggle('active', id === 'all' || sec.id === id));
        chips.forEach(chip => chip.classList.toggle('active', chip.dataset.section === id || id === 'all'));
      }

      chips.forEach(chip => chip.addEventListener('click', () => showSection(chip.dataset.section)));
      showAllBtn.addEventListener('click', () => showSection('all'));
      showSection('all');
    });
  </script>

</body>

</html>