<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebGL → OpenGL C++ → WebGPU: Ultimate Performance Guide</title>
  <link rel="stylesheet" href="./guide-style.css" />
  <!-- Mermaid -->
  <script src="/lib/mermaid.min.js"></script>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: 'dark',
      securityLevel: 'loose',
      flowchart: { useMaxWidth: true, htmlLabels: true }
    });
  </script>
</head>

<body>


  <header>
    <h1>WebGL → OpenGL C++ → WebGPU: Ultimate Performance Guide</h1>
    <p class="note">From legacy WebGL to native OpenGL C++ and cutting-edge WebGPU. This guide covers <strong>maximum
        performance</strong> across web (WASM) and desktop. Click to filter sections.</p>

    <div class="toc">
      <div class="chip" data-section="all">Show All</div>
      <div class="chip active" data-section="webgl">WebGL</div>
      <div class="chip" data-section="opengl">OpenGL C++</div>
      <div class="chip" data-section="webgpu">WebGPU</div>
      <div class="chip" data-section="wasm">WASM & Emscripten</div>
      <div class="chip" data-section="perf">Performance</div>
      <div class="chip" data-section="interop">Interop & Migration</div>
    </div>
  </header>

  <button id="show-all-btn">Show All Sections</button>

  <!-- WEBGL -->
  <section id="webgl" class="section active">
    <h2>WebGL: High-Performance JS</h2>
    <div class="row">
      <div class="col">
        <h3>Core Setup</h3>
        <pre>const gl = canvas.getContext('webgl2', { 
  antialias: true, 
  depth: true, 
  preserveDrawingBuffer: false 
});
gl.getExtension('EXT_color_buffer_float');</pre>
        <div class="perf"><strong>Perf Tip:</strong> Use <code>webgl2</code> + <code>preserveDrawingBuffer: false</code>
          to avoid CPU readbacks.</div>
      </div>
      <div class="col">
        <h3>Instancing & UBOs</h3>
        <pre>// WebGL 2: UBOs via extension
const ubo = gl.createBuffer();
gl.bindBufferBase(gl.UNIFORM_BUFFER, 0, ubo);
gl.bufferData(gl.UNIFORM_BUFFER, 64, gl.DYNAMIC_DRAW);</pre>
        <div class="tip"><strong>Instancing:</strong> <code>ANGLE_instanced_arrays.drawArraysInstancedANGLE()</code>
        </div>
      </div>
    </div>
  </section>

  <!-- OPENGL C++ -->
  <section id="opengl" class="section">
    <h2>OpenGL C++: Native Maximum Speed</h2>
    <div class="row">
      <div class="col">
        <h3>Core Profile 4.6</h3>
        <pre>#include &lt;glad/glad.h&gt;
glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</pre>
        <div class="perf"><strong>Perf:</strong> Use <code>GL_ARB_direct_state_access</code> to avoid binding:</div>
        <pre>glCreateBuffers(1, &vbo);
glNamedBufferData(vbo, size, data, GL_STATIC_DRAW);</pre>
      </div>
      <div class="col">
        <h3>Bindless Textures</h3>
        <pre>GLuint64 handle = glGetTextureHandleARB(tex);
glMakeTextureHandleResidentARB(handle);</pre>
        <div class="tip">Eliminates texture unit limits. Ideal for 1000+ textures.</div>
      </div>
    </div>
  </section>

  <!-- WEBGPU -->
  <section id="webgpu" class="section">
    <h2>WebGPU: Next-Gen Web Graphics</h2>
    <div class="row">
      <div class="col">
        <h3>Setup & Pipeline</h3>
        <pre>const adapter = await navigator.gpu.requestAdapter();
const device = await adapter.requestDevice();
const pipeline = device.createRenderPipeline({
  vertex: { module: shaderModule, entryPoint: 'vs_main' },
  fragment: { module: shaderModule, entryPoint: 'fs_main' },
  primitive: { topology: 'triangle-list' }
});</pre>
        <div class="perf"><strong>Perf:</strong> WebGPU is <strong>explicit</strong> — no hidden state. Use
          <code>GPUBufferUsage.STORAGE</code> for compute-like rendering.
        </div>
      </div>
      <div class="col">
        <h3>WGSL vs GLSL</h3>
        <table>
          <tr>
            <th>GLSL</th>
            <th>WGSL</th>
          </tr>
          <tr>
            <td><code>layout(location=0) in vec3 pos;</code></td>
            <td><code>@location(0) var&lt;input&gt; pos: vec3&lt;f32&gt;;</code></td>
          </tr>
          <tr>
            <td><code>uniform mat4 u_mvp;</code></td>
            <td><code>@group(0) @binding(0) var&lt;uniform&gt; u_mvp: mat4x4&lt;f32&gt;;</code></td>
          </tr>
        </table>
        <div class="tip">WGSL is stricter, safer, and enables better optimization.</div>
      </div>
    </div>
  </section>

  <!-- WASM & EMSCRIPTEN -->
  <section id="wasm" class="section">
    <h2>WASM + Emscripten: C++ to Web</h2>
    <div class="row">
      <div class="col">
        <h3>Compile OpenGL C++ to WebGL</h3>
        <pre>emcc main.cpp -O3 \
  -s USE_WEBGL2=1 \
  -s FULL_ES3=1 \
  -s ALLOW_MEMORY_GROWTH=1 \
  -s MAX_WEBGL_VERSION=2 \
  -o game.html</pre>
        <div class="perf"><strong>Perf:</strong> Add <code>-s GL_POOL_TEMP_BUFFERS=0</code> to reduce GC pressure.</div>
      </div>
      <div class="col">
        <h3>WebGPU via Dawn + WASM</h3>
        <pre>emcc --use-dawn \
  -s USE_WEBGPU=1 \
  -s GL_SUPPORT_AUTOMATIC_ENABLE_EXTENSIONS=0</pre>
        <div class="tip">Dawn is Google’s WebGPU implementation. Use with Emscripten for C++ WebGPU.</div>
      </div>
    </div>
  </section>

  <!-- PERFORMANCE -->
  <section id="perf" class="section">
    <h2>Performance: Max FPS, Min Latency</h2>
    <div class="row">
      <div class="col">
        <h3>Batching & State Sorting</h3>
        <div class="diagram">
          <div class="mermaid">
            graph TD
            A[Sort by Shader] --> B[Sort by Texture]
            B --> C[Sort by VBO]
            C --> D[Instanced Draw]
            classDef perf fill:#050,stroke:#0f0
            class A,B,C,D perf
          </div>
        </div>
        <div class="perf"><strong>Rule:</strong> Change state as infrequently as possible. Use <code>glMultiDraw*</code>
          in OpenGL.</div>
      </div>
      <div class="col">
        <h3>Memory & Uploads</h3>
        <table>
          <tr>
            <th>API</th>
            <th>Fast Upload</th>
          </tr>
          <tr>
            <td>WebGL</td>
            <td><code>gl.bufferSubData()</code> + PBO (extension)</td>
          </tr>
          <tr>
            <td>OpenGL</td>
            <td><code>glMapBufferRange()</code> + persistent mapping</td>
          </tr>
          <tr>
            <td>WebGPU</td>
            <td><code>queue.writeBuffer()</code> or <code>GPUBuffer.mapAsync()</code></td>
          </tr>
        </table>
        <div class="perf"><strong>Best:</strong> Persistent mapped buffers (OpenGL 4.4+) or
          <code>queue.writeBuffer()</code> in WebGPU.
        </div>
      </div>
    </div>
  </section>

  <!-- INTEROP & MIGRATION -->
  <section id="interop" class="section">
    <h2>Interop & Migration Path</h2>
    <div class="row">
      <div class="col">
        <h3>Shared Code Strategy</h3>
        <div class="diagram">
          <div class="mermaid">
            graph TD
            Core[Core Logic] --> WebGL[WebGL Renderer]
            Core --> OpenGL[OpenGL C++]
            Core --> WebGPU[WebGPU JS]
            WebGL --> WASM[WASM Bridge]
            OpenGL --> Emscripten[Emscripten]
            classDef core fill:#022
            class Core core
          </div>
        </div>
        <div class="tip">Write renderer-agnostic core. Swap backends at compile time.</div>
      </div>
      <div class="col">
        <h3>Migration Table</h3>
        <table>
          <tr>
            <th>From → To</th>
            <th>Effort</th>
            <th>Perf Gain</th>
          </tr>
          <tr>
            <td>WebGL → OpenGL C++</td>
            <td>Medium</td>
            <td>5–10×</td>
          </tr>
          <tr>
            <td>WebGL → WebGPU</td>
            <td>High</td>
            <td>2–4×</td>
          </tr>
          <tr>
            <td>OpenGL → WebGPU</td>
            <td>High</td>
            <td>1.2–2×</td>
          </tr>
        </table>
        <div class="perf"><strong>Best ROI:</strong> WebGL → OpenGL C++ via Emscripten.</div>
      </div>
    </div>
  </section>

  <footer>
    <p>Ultimate performance guide. From WebGL to native OpenGL and WebGPU. Use WASM for cross-platform deployment.</p>
    <p>— Build once. Run everywhere. At maximum speed.</p>
  </footer>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const chips = document.querySelectorAll('.chip');
      const sections = document.querySelectorAll('.section');
      const showAllBtn = document.getElementById('show-all-btn');

      function showSection(id) {
        sections.forEach(sec => sec.classList.toggle('active', id === 'all' || sec.id === id));
        chips.forEach(chip => chip.classList.toggle('active', chip.dataset.section === id || id === 'all'));
      }

      chips.forEach(chip => chip.addEventListener('click', () => showSection(chip.dataset.section)));
      showAllBtn.addEventListener('click', () => showSection('all'));
    });
  </script>

</body>

</html>